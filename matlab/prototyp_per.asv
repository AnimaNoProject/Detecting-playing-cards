% Prototype here please %

%1. Karten teilen/ 2 separate bilder erstellen mit je 1 Karte
%2. Geometrisch projezieren / homogenes Bild erhalten
%3. Template matching - resultat erhalten

% Original Image
input = imread('input/test_img_pers.jpg');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Grayscale image
input_gray = rgb2gray(input);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Binarized Image
binaryInput = imbinarize(input_gray, 0.5);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% connected components
CC = bwconncomp(binaryInput);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Dummy Image
BW2 = zeros(size(binaryInput)); 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sort biggest Components
numPixels = cellfun(@numel,CC.PixelIdxList);
[biggest, idx] = sort(numPixels,'descend');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Fill the holes in the 2 components
card_first = zeros(size(binaryInput));
card_first(CC.PixelIdxList{idx(1)}) = 1;
filled_first = imfill(card_first, 'holes');

card_second = zeros(size(binaryInput));
card_second(CC.PixelIdxList{idx(2)}) = 1;
filled_second = imfill(card_second, 'holes');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Decide which card is bigger by comparing the pixels
if(sum(filled_first) > sum(filled_second))
    card_first = filled_first;
    card_second = filled_second;
else
    card_first = filled_second;
    card_second = filled_first;
end;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Get the RGB card from the Original image by dotmultiplying with the binary
%image
card_one = input;
card_two = input;

card_one(:,:,1) = double(card_one(:,:,1)) .* card_first(:,:);
card_one(:,:,2) = double(card_one(:,:,2)) .* card_first(:,:);
card_one(:,:,3) = double(card_one(:,:,3)) .* card_first(:,:);

card_two(:,:,1) = double(card_two(:,:,1)) .* card_second(:,:);
card_two(:,:,2) = double(card_two(:,:,2)) .* card_second(:,:);
card_two(:,:,3) = double(card_two(:,:,3)) .* card_second(:,:);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Show both cards
imshowpair(card_one, card_two, 'Montage');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%grayscale of the two single cards
card_one_gray = rgb2gray(card_one);
card_two_gray = rgb2gray(card_two);


%%%%%%%%find corner%%%%%%%%%%%%%
%get bounding box of binary images
boundingbox     = regionprops(card_first, 'BoundingBox');
boxproperties   = boundingbox.BoundingBox;
left            = round(boxproperties(1));
top             = round(boxproperties(2));
width           = boxproperties(3);
height          = boxproperties(4);
right           = round(boxproperties(1) + width) - 1;
bottom          = round(boxproperties(2) + height) - 1;
firstcorner     = -1;
secondcorner    = -1;
thirdcorner     = -1;
fourthcorner    = -1;
%get first corner from top left to top right
for x = left : right
    value = card_first(top, x);
    if(value == 1)
        firstcorner = [top, x];
        break;
    end
end
%get second corner from top left to bottom left
for y = top : bottom
    value = card_first(y, left);
    if(value == 1)
        secondcorner = [y, left];
        break;
    end
end
%get third corner top right to bottom right
for y = top : bottom
    value = card_first(y, right);
    if(value == 1)
        thirdcorner = [y, right];
        break;
    end
end
%get fourth corner from bottom left to bottom right
for x = left : right
    value = card_first(bottom, x);
    if(value == 1)
        fourthcorner = [bottom, x];
        break;
    end
end
corners = [firstcorner;secondcorner;thirdcorner;fourthcorner];

figure();
imshow(card_one_gray);
hold on;
plot(firstcorner(2),firstcorner(1), '*');
plot(secondcorner(2),secondcorner(1), '*');
plot(thirdcorner(2),thirdcorner(1), '*');
plot(fourthcorner(2),fourthcorner(1), '*');
hold off;

% perspektive
r = [firstcorner(1) secondcorner(1) thirdcorner(1) fourthcorner(1)]';
c = [firstcorner(2) secondcorner(2) thirdcorner(2) fourthcorner(2)]';
% Kartenverhältnis 5:8
base = [5 0; 0 0; 5 8; 0 8];
tf = cp2tform([c r], base*2000,'projective');
disp('tf = ');
disp(tf)
disp('tf.tdata = ');
disp(tf.tdata);

T=tf.tdata.T;
disp('T = ');
format short g
disp(T);
format

[xf1, XData, YData] = imtransform(card_one_gray,tf);
figure;
imshow(xf1);


%{
X1 = [ firstcorner;secondcorner;thirdcorner;fourthcorner]';
 
X2 = [ 170 600 170 600
       132 132 1072 1072];
 
% create [H]
A = [];
for i = 1:4
  x1 = [X1(:,i);1];    % Get ith point in original image in homogeneous coords
  x2x = X2(1,i);       % Get x coordinate of destintion point
  x2y = X2(2,i);       % Get y coordinate of destination point
  ThisA = [ -x1', 0, 0, 0, x2x * x1' ;
            0, 0, 0, -x1', x2y * x1' ];
  A = [ A ; ThisA ];
end
 
H = reshape(null(A),3,3)';
 
 
 
% map all pixel in input image, [input_image], size MxN to temporary matrix, [tmp],  size 2 x M*N
[M,N] = size(input);
M;
N;
tmp = zeros(2,M*N);
for i = 1:M
    for j = 1:N
        tmp(1,(N*(i-1))+j) = i;
        tmp(2,(N*(i-1))+j) = j;        
    end
end
 
% convert [tmp] size 2 x M*N  to be [tmp]  size 3 x M*N by pad [1] size 1xM*N at the 3rd row
% apply X2 = H.X1
X2 = H * [ tmp ; ones(1,M*N) ];
 
% normalize [X2]
 %X2 = mapped(1:2,:) ./ repmat(mapped(3,:),2,1);
 
 
 
% map [X2] size 3xM*N back to [output] size MxNx3
output = zeros(M,N,3);
 
for i = 1:M
    for j = 1:N
        row = round(X2(1,(N*(i-1))+j));
        col = round(X2(2,(N*(i-1))+j));
 
        if 0 < row & row < M & 0 < col & col < N
%            [xx yy];
%            disp( 'in range' )
            output(row,col,1) = input(i,j,1);
            output(row,col,2) = input(i,j,2);
            output(row,col,3) = input(i,j,3);
        else
%            disp('out range')
        end
    end
end
 
disp('finish')

%}